# How Leviathan Operates a Repository

## Overview

Leviathan is an **autonomous execution platform** that operates target repositories through explicit, auditable, PR-based workflows. It is **not** an autonomous planning system—all work is governed by explicit contracts and backlogs.

## Core Principles

1. **Explicit Governance**: All actions defined in contract.yaml, backlog.yaml, and policy.yaml
2. **PR-Based Workflow**: Every change creates a PR for human review
3. **Auditable**: All events logged to append-only event store
4. **Human-in-the-Loop**: Humans approve PRs before merge
5. **No Autonomous Planning**: Leviathan executes tasks, it does not invent them

## Target Registration

A target repository opts into Leviathan by providing three files in `.leviathan/`:

### 1. contract.yaml - Repository Metadata

```yaml
target_id: my-repo
name: My Repository
repo_url: git@github.com:owner/my-repo.git
default_branch: main
description: "Production service for X"
owner: team-platform
created_at: "2024-01-01T00:00:00Z"
```

**Purpose**: Identifies the repository and its ownership.

### 2. backlog.yaml - Explicit Task Queue

```yaml
tasks:
  - task_id: task-001
    title: "Update dependencies"
    scope: dependencies
    priority: high
    estimated_size: small
    allowed_paths:
      - requirements.txt
      - package.json
    acceptance_criteria:
      - "All dependencies updated to latest compatible versions"
      - "Tests pass"
    status: pending
    
  - task_id: task-002
    title: "Add logging to API endpoints"
    scope: observability
    priority: medium
    estimated_size: medium
    allowed_paths:
      - src/api/**/*.py
    acceptance_criteria:
      - "All endpoints log request/response"
      - "Structured logging format"
    status: pending
```

**Purpose**: Defines the work queue. Humans add tasks here explicitly.

**Key Points**:
- Tasks are **not** generated by Leviathan
- Each task has explicit allowed_paths (scope boundaries)
- Priority and size are human-specified
- Status tracks execution state

### 3. policy.yaml - Governance Rules

```yaml
scopes:
  dependencies:
    allowed_paths:
      - requirements.txt
      - package.json
      - Gemfile
    forbidden_patterns:
      - "src/**"
      - "tests/**"
  
  observability:
    allowed_paths:
      - "src/**/*.py"
    forbidden_patterns:
      - "tests/**"
      - "config/**"

invariants:
  - name: "Tests must pass"
    check: "pytest tests/"
    
  - name: "Linting must pass"
    check: "ruff check ."
    
  - name: "No secrets in code"
    check: "detect-secrets scan"
```

**Purpose**: Enforces boundaries and quality gates.

**Key Points**:
- Scopes define what files can be modified for each task type
- Invariants are checked before PR creation
- Violations block PR creation

## Execution Flow

### 1. Scheduler Selects Task

```
Scheduler:
  1. Read backlog.yaml from target repo
  2. Filter tasks by status=pending
  3. Sort by priority (high > medium > low)
  4. Select highest priority task
  5. Create attempt record in event store
```

**Human Control**: Humans control what runs by setting task priorities and status.

### 2. Executor Runs Task

```
Executor (K8s Job or Worktree):
  1. Clone target repo
  2. Load task spec from backlog.yaml
  3. Load policy from policy.yaml
  4. Execute task with Claude API
  5. Validate changes against policy
  6. Run invariant checks
  7. Create PR if all checks pass
  8. Log all events to control plane
```

**Guardrails**:
- Task can only modify files in allowed_paths
- All invariants must pass
- Changes are scoped to task boundaries
- PR created, not merged

### 3. Human Reviews PR

```
Human:
  1. Review PR created by Leviathan
  2. Check changes against task acceptance criteria
  3. Verify no unexpected modifications
  4. Approve and merge, or request changes
```

**Human Control**: Humans have final approval on all changes.

### 4. Event Logging

All actions logged to append-only event store:

```
Events:
  - task.created
  - attempt.created
  - attempt.started
  - attempt.completed
  - pr.created
  - pr.merged (external)
  - attempt.failed
```

**Auditability**: Full history of what Leviathan did and why.

## Workflow Example

### Scenario: Update Python Dependencies

**Step 1: Human adds task to backlog.yaml**

```yaml
- task_id: task-deps-2024-01
  title: "Update Python dependencies to latest"
  scope: dependencies
  priority: high
  estimated_size: small
  allowed_paths:
    - requirements.txt
  acceptance_criteria:
    - "All dependencies updated to latest compatible versions"
    - "Tests pass"
  status: pending
```

**Step 2: Scheduler picks task**

```
Scheduler runs (cron or manual trigger)
→ Reads backlog.yaml
→ Finds task-deps-2024-01 (status=pending, priority=high)
→ Creates attempt record
→ Dispatches to executor
```

**Step 3: Executor runs**

```
Executor:
→ Clones repo
→ Reads task spec
→ Calls Claude API with prompt:
  "Update requirements.txt to latest compatible versions.
   Run tests to verify compatibility.
   Only modify requirements.txt."
→ Claude updates requirements.txt
→ Executor runs: pytest tests/
→ Tests pass ✓
→ Executor validates: only requirements.txt modified ✓
→ Executor creates PR
```

**Step 4: PR Created**

```
PR #123: "Update Python dependencies to latest"

Changes:
  requirements.txt: 15 dependencies updated

Checks:
  ✓ Tests passed
  ✓ Only allowed files modified
  ✓ No secrets detected

Leviathan Metadata:
  Task: task-deps-2024-01
  Attempt: attempt-abc123
  Executor: k8s-job-xyz
```

**Step 5: Human reviews and merges**

```
Human:
→ Reviews PR #123
→ Checks dependency updates are reasonable
→ Approves and merges
```

**Step 6: Backlog updated**

```
Scheduler (post-merge):
→ Detects PR merged
→ Updates backlog.yaml:
  task-deps-2024-01: status=completed
→ Commits updated backlog
```

## Human-in-the-Loop Guarantees

### What Leviathan DOES

✅ Execute tasks from explicit backlog
✅ Create PRs for human review
✅ Enforce policy boundaries
✅ Log all actions
✅ Run quality checks

### What Leviathan DOES NOT DO

❌ Invent new tasks
❌ Merge PRs automatically
❌ Modify files outside allowed_paths
❌ Skip invariant checks
❌ Make architectural decisions
❌ Plan roadmaps

## Operational Control

### Starting Leviathan

```bash
# Deploy control plane (K8s)
kubectl apply -f ops/k8s/control-plane.yaml

# Register target
kubectl create configmap leviathan-target-myrepo \
  --from-file=contract.yaml=~/.leviathan/targets/myrepo.yaml

# Scheduler runs on cron or manual trigger
kubectl create job leviathan-scheduler-run \
  --from=cronjob/leviathan-scheduler
```

### Monitoring

```bash
# View graph summary
leviathanctl graph-summary

# List recent attempts
leviathanctl attempts-list --limit 20

# Check failures
leviathanctl failures-recent --limit 10

# View specific attempt
leviathanctl attempts-show attempt-abc123
```

### Emergency Stop

```bash
# Pause all execution
kubectl scale deployment leviathan-scheduler --replicas=0

# Cancel running jobs
kubectl delete jobs -l app=leviathan-executor

# Invalidate pending attempts
leviathanctl invalidate attempt-xyz --reason "Emergency stop"
```

## Safety Mechanisms

### 1. Scope Enforcement

Tasks can only modify files in `allowed_paths`:

```yaml
task:
  allowed_paths:
    - src/api/*.py
  
# Executor will REJECT changes to:
# - src/database/*.py (not in allowed_paths)
# - tests/*.py (not in allowed_paths)
# - config/*.yaml (not in allowed_paths)
```

### 2. Invariant Checks

All invariants must pass before PR creation:

```yaml
invariants:
  - name: "Tests pass"
    check: "pytest tests/"
  - name: "Linting passes"
    check: "ruff check ."
```

If any check fails → No PR created, attempt marked failed.

### 3. PR-Based Review

Every change goes through PR:
- Humans review all changes
- Humans approve or reject
- No automatic merges

### 4. Audit Trail

All events logged:
- What task was executed
- What changes were made
- What checks passed/failed
- What PR was created
- Who approved/merged

## Configuration Management

### Target Configuration

Stored in control plane as ConfigMap:

```bash
kubectl create configmap leviathan-target-myrepo \
  --from-file=contract.yaml \
  --from-file=backlog.yaml \
  --from-file=policy.yaml
```

### Secrets

Required secrets:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: leviathan-secrets
type: Opaque
stringData:
  LEVIATHAN_CONTROL_PLANE_TOKEN: "secure-token-here"
  ANTHROPIC_API_KEY: "claude-api-key-here"
  GITHUB_TOKEN: "github-pat-here"
```

### Environment Variables

```bash
# Control Plane
LEVIATHAN_CONTROL_PLANE_TOKEN=<token>
LEVIATHAN_BACKEND=ndjson|postgres
LEVIATHAN_POSTGRES_URL=<url>  # if postgres

# Executor
LEVIATHAN_CONTROL_PLANE_URL=http://control-plane:8000
LEVIATHAN_CONTROL_PLANE_TOKEN=<token>
ANTHROPIC_API_KEY=<key>
GITHUB_TOKEN=<token>
```

## Failure Handling

### Attempt Failures

When an attempt fails:

```
1. Executor logs failure event
2. Attempt marked as failed in graph
3. Task remains in backlog (status=pending)
4. Scheduler can retry on next run
```

### Manual Intervention

```bash
# View failure details
leviathanctl attempts-show attempt-failed-123

# Invalidate and retry
leviathanctl invalidate attempt-failed-123 \
  --reason "Transient API error, retry"

# Scheduler will pick up task again
```

### Circuit Breaker

If a task fails repeatedly:

```yaml
# Manually update backlog.yaml
tasks:
  - task_id: problematic-task
    status: blocked  # Prevents scheduler from picking it
    blocked_reason: "Needs investigation - fails on step X"
```

## Best Practices

### 1. Small, Focused Tasks

❌ Bad:
```yaml
- title: "Refactor entire codebase"
  allowed_paths: ["**/*.py"]
```

✅ Good:
```yaml
- title: "Add logging to user API endpoints"
  allowed_paths: ["src/api/users/*.py"]
```

### 2. Explicit Acceptance Criteria

❌ Bad:
```yaml
acceptance_criteria:
  - "Make it better"
```

✅ Good:
```yaml
acceptance_criteria:
  - "All user API endpoints log request/response"
  - "Logs include user_id and request_id"
  - "Tests pass"
```

### 3. Narrow Scopes

❌ Bad:
```yaml
scopes:
  general:
    allowed_paths: ["**/*"]
```

✅ Good:
```yaml
scopes:
  api:
    allowed_paths: ["src/api/**/*.py"]
  tests:
    allowed_paths: ["tests/**/*.py"]
```

### 4. Strong Invariants

```yaml
invariants:
  - name: "Tests pass"
    check: "pytest tests/ --cov=80"
  - name: "Type checking passes"
    check: "mypy src/"
  - name: "No secrets"
    check: "detect-secrets scan"
  - name: "Security scan passes"
    check: "bandit -r src/"
```

## Summary

Leviathan operates repositories through:

1. **Explicit Contracts**: Targets opt-in with contract, backlog, and policy
2. **Backlog-Driven**: Humans define tasks, Leviathan executes them
3. **PR-Based**: Every change creates a PR for human review
4. **Scoped Execution**: Tasks can only modify allowed files
5. **Quality Gates**: Invariants must pass before PR creation
6. **Audit Trail**: All actions logged to event store
7. **Human Control**: Humans approve all changes

**Leviathan is boring by design**: It executes explicit work, creates PRs, and waits for human approval. No surprises, no autonomous planning, no magic.
